from collections import defaultdict


def smartdict_nan(key):
    return 10 * key


N = 10
smartdict = {}
for key in range(N):
    val = defaultdict(lambda loc_key=key: smartdict_nan(loc_key))
    smartdict[key] = val

# Первоначальное решение не работало, потому что функция,
# которая внутри defaultdict, она вызывается не 10 раз внутри цикла,
# а только после цикла, когда мы уже непосредственно
# пишем smartdict[2]['unknown_key']; только в этот момент, при встрече
# c отсутствующим ключом, вызывается моя lambda-функция,
# а в цикле она не вызывалась, а просто запомнился адрес, где она лежит
# (и после цикла можно написать repr(smartdict[i].default_factory)
# и там видно, что у этих функций разные адреса); но у лямбда-функции
# проблема в том, что она предпочитает связываться с бегающей по циклу
# переменной key, поэтому все 9 лямбда-функций запомнят ее адрес,
# она будет меняться в цикле, а у них ее адрес лежит,
# поэтому у всех них после цикла по этому адресу будет лежать
# одна и та же девятка; а если написать
# defaultdict(lambda loc_key=key: smartdict_nan(loc_key)), то
# loc_key уже будет локальной переменной, и ее адрес уже будет
# разный у каждой из лямбда-функций в цикле, а значение будет нужным числом;
# при этом лямбда-функция не будет требовать значения на вход, потому что
# мы ей поставили значение по умолчанию равным key
